<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Bloom Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, collection, serverTimestamp, runTransaction, arrayUnion, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration (Provided by Canvas Environment) ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "YOUR_AUTH_DOMAIN", projectId: "YOUR_PROJECT_ID", storageBucket: "YOUR_STORAGE_BUCKET", messagingSenderId: "YOUR_MESSAGING_SENDER_ID", appId: "YOUR_APP_ID" }; // Fallback for local dev
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'daily-quiz-game-dev';

        // --- Initialize Firebase ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        setLogLevel('debug'); // For detailed Firestore logs

        // --- Global State ---
        let currentUser = null;
        let currentRoomId = null;
        let currentUsername = '';
        let roomUnsubscribe = null;
        let gameUnsubscribe = null;
        let roundTimerInterval = null;
        const ROUND_DURATION = 60; // seconds

        // --- UI Elements ---
        const screens = {
            home: document.getElementById('homeScreen'),
            lobby: document.getElementById('lobbyScreen'),
            game: document.getElementById('gameScreen'),
            gameOver: document.getElementById('gameOverScreen'),
        };
        const usernameInput = document.getElementById('usernameInput');
        const createRoomButton = document.getElementById('createRoomButton');
        const joinRoomButton = document.getElementById('joinRoomButton');
        const roomIdInput = document.getElementById('roomIdInput');
        const difficultySelect = document.getElementById('difficultySelect');
        
        const currentRoomIdDisplay = document.getElementById('currentRoomIdDisplay');
        const playerListLobby = document.getElementById('playerListLobby');
        const startGameButton = document.getElementById('startGameButton');
        const leaveLobbyButton = document.getElementById('leaveLobbyButton'); 
        
        const questionDisplay = document.getElementById('questionDisplay');
        const answerInput = document.getElementById('answerInput');
        const submitAnswerButton = document.getElementById('submitAnswerButton');
        const timerDisplay = document.getElementById('timerDisplay');
        const player1NameGame = document.getElementById('player1NameGame');
        const player1ScoreGame = document.getElementById('player1ScoreGame');
        const player1AnswerStatus = document.getElementById('player1AnswerStatus');
        const player2NameGame = document.getElementById('player2NameGame');
        const player2ScoreGame = document.getElementById('player2ScoreGame');
        const player2AnswerStatus = document.getElementById('player2AnswerStatus');
        const roundInfoDisplay = document.getElementById('roundInfoDisplay');
        const waitingForQuestionSpinner = document.getElementById('waitingForQuestionSpinner');
        const answerCountDisplay = document.getElementById('answerCountDisplay');
        const leaveGameButton = document.getElementById('leaveGameButton'); 

        const winnerInfo = document.getElementById('winnerInfo');
        const finalScoresList = document.getElementById('finalScoresList');
        const playAgainButton = document.getElementById('playAgainButton');
        const backToHomeButton = document.getElementById('backToHomeButton');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const closeMessageButton = document.getElementById('closeMessageButton');

        // --- Helper Functions ---
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.add('hidden'));
            if (screens[screenName]) {
                screens[screenName].classList.remove('hidden');
            }
             // Scroll to top when changing screens for better UX on mobile
            window.scrollTo(0, 0);
        }

        function showMessage(message, duration = 3000) {
            messageText.textContent = message;
            messageOverlay.classList.remove('hidden');
            if (duration) {
                setTimeout(() => {
                    messageOverlay.classList.add('hidden');
                }, duration);
            }
        }
        closeMessageButton.addEventListener('click', () => messageOverlay.classList.add('hidden'));

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 7).toUpperCase();
        }

        // --- Authentication ---
        async function initializeAuth() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } else {
                    await signInAnonymously(auth);
                    console.log("Signed in anonymously.");
                }
            } catch (error) {
                console.error("Error during sign-in:", error);
                showMessage("Error signing in. Please refresh.", null);
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    console.log("User authenticated:", currentUser.uid);
                } else {
                    currentUser = null;
                    console.log("User signed out.");
                    showScreen('home'); 
                }
            });
        }

        // --- Gemini API for Question Generation ---
        async function generateQuestionWithGemini(difficulty) {
            if (!currentUser) {
                showMessage("User not authenticated to generate question.", null);
                return null;
            }
            waitingForQuestionSpinner.classList.remove('hidden');
            questionDisplay.textContent = "Crafting a curious question...";
            submitAnswerButton.disabled = true;

            const prompt = `Generate a question for a 2-player quiz game. The question should ask players to list exactly 8 items related to daily life, work, or common knowledge. The question itself should be a single concise sentence. Difficulty: ${difficulty}. Example: 'List 8 common fruits.' or 'Name 8 tasks you typically do before 9 AM on a workday.'`;
            
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Gemini API error:", errorData);
                    throw new Error(`Gemini API request failed: ${response.statusText}`);
                }
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    console.log("Generated question:", text);
                    waitingForQuestionSpinner.classList.add('hidden');
                    questionDisplay.textContent = text;
                    submitAnswerButton.disabled = false;
                    return text;
                } else {
                    console.error("Unexpected Gemini API response structure:", result);
                    throw new Error("Failed to parse question from Gemini API response.");
                }
            } catch (error) {
                console.error("Error generating question with Gemini:", error);
                showMessage("Oops! Could not think of a question. Please try again.", null);
                waitingForQuestionSpinner.classList.add('hidden');
                questionDisplay.textContent = "Error generating question. Host might need to try starting round again.";
                submitAnswerButton.disabled = true;
                return null;
            }
        }

        // --- Room Management ---
        createRoomButton.addEventListener('click', async () => {
            currentUsername = usernameInput.value.trim();
            if (!currentUsername) {
                showMessage("Please choose a delightful username!");
                return;
            }
            if (!currentUser) {
                showMessage("Hold on! Still connecting. Please wait or refresh.", null);
                return;
            }

            currentRoomId = generateRoomId();
            const roomRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}`);
            const selectedDifficulty = difficultySelect.value;

            try {
                await setDoc(roomRef, {
                    roomId: currentRoomId,
                    creatorUid: currentUser.uid,
                    status: 'waiting', 
                    difficulty: selectedDifficulty,
                    createdAt: serverTimestamp(),
                    players: {
                        [currentUser.uid]: {
                            username: currentUsername,
                            score: 0,
                            isHost: true,
                            joinedAt: serverTimestamp()
                        }
                    },
                    playerOrder: [currentUser.uid] 
                });
                console.log("Room created:", currentRoomId);
                joinRoom(currentRoomId);
            } catch (error) {
                console.error("Error creating room:", error);
                showMessage("Oh dear, couldn't create the room. Please try again.", null);
            }
        });

        joinRoomButton.addEventListener('click', () => {
            currentUsername = usernameInput.value.trim();
            if (!currentUsername) {
                showMessage("A lovely username is needed to join!");
                return;
            }
            const inputRoomId = roomIdInput.value.trim().toUpperCase();
            if (!inputRoomId) {
                showMessage("Please enter the Room ID to join the fun.");
                return;
            }
            if (!currentUser) {
                showMessage("Patience, young grasshopper! Still connecting. Please wait or refresh.", null);
                return;
            }
            joinRoom(inputRoomId);
        });

        async function joinRoom(roomIdToJoin) {
            const roomRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${roomIdToJoin}`);
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) {
                        throw new Error("Hmm, that room doesn't seem to exist.");
                    }
                    const roomData = roomDoc.data();
                    if (Object.keys(roomData.players || {}).length >= 2 && !roomData.players[currentUser.uid]) {
                        throw new Error("This room is bustling! It's full right now.");
                    }
                    if (roomData.status === 'playing' && !roomData.players[currentUser.uid]) {
                        throw new Error("The game's afoot! Already in progress.");
                    }

                    let playerOrder = roomData.playerOrder || [];
                    if (!playerOrder.includes(currentUser.uid)) {
                        playerOrder.push(currentUser.uid);
                    }
                    
                    transaction.update(roomRef, {
                        [`players.${currentUser.uid}`]: {
                            username: currentUsername,
                            score: 0,
                            isHost: roomData.creatorUid === currentUser.uid,
                            joinedAt: serverTimestamp()
                        },
                        playerOrder: playerOrder
                    });
                });

                currentRoomId = roomIdToJoin;
                showScreen('lobby');
                currentRoomIdDisplay.textContent = `Room ID: ${currentRoomId}`;
                subscribeToRoomUpdates(currentRoomId);

            } catch (error) {
                console.error("Error joining room:", error);
                showMessage(error.message || "Couldn't join the room. Maybe try again?", null);
            }
        }

        function subscribeToRoomUpdates(roomId) {
            if (roomUnsubscribe) roomUnsubscribe();
            const roomRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${roomId}`);
            roomUnsubscribe = onSnapshot(roomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showMessage("The room seems to have vanished! Returning home.", null);
                    leaveRoom(); 
                    return;
                }
                const roomData = docSnap.data();
                updateLobbyUI(roomData);

                if (roomData.status === 'playing' && screens.game.classList.contains('hidden')) {
                    showScreen('game');
                    subscribeToGameUpdates(roomId, roomData.currentGameId);
                    initializeGameUI(roomData);
                } else if (roomData.status === 'waiting' && !screens.lobby.classList.contains('hidden')) {
                    // Stay in lobby
                } else if (roomData.status === 'finished' && roomData.currentGameId) {
                     if (gameUnsubscribe) gameUnsubscribe(); 
                    subscribeToGameUpdates(roomId, roomData.currentGameId, true); 
                }
            }, (error) => {
                console.error("Error listening to room updates:", error);
                showMessage("Lost connection to the room. Trying to reconnect...", null);
                // Consider a more graceful reconnect attempt or guiding user back home.
                // For now, leaveRoom() will take them home after this message.
                setTimeout(() => leaveRoom(), 3000); 
            });
        }
        
        function updateLobbyUI(roomData) {
            if (!screens.lobby.classList.contains('hidden')) {
                playerListLobby.innerHTML = '';
                const players = roomData.players || {};
                const playerIds = roomData.playerOrder || Object.keys(players);

                playerIds.forEach(uid => {
                    const player = players[uid];
                    if (player) {
                        const li = document.createElement('li');
                        li.className = 'p-3 bg-white/20 rounded-lg shadow text-gray-800 text-lg';
                        li.textContent = `${player.username} ${uid === currentUser.uid ? '(You!)' : ''} ${player.isHost ? '👑 (Host)' : ''}`;
                        playerListLobby.appendChild(li);
                    }
                });

                const numPlayers = playerIds.length;
                if (numPlayers >= 2 && roomData.creatorUid === currentUser.uid) {
                    startGameButton.classList.remove('hidden');
                    startGameButton.disabled = false;
                } else {
                    startGameButton.classList.add('hidden');
                    startGameButton.disabled = true;
                }
                 if (numPlayers < 2) {
                    playerListLobby.innerHTML += '<li class="p-3 text-teal-700 animate-pulse">Waiting for a friend to join...</li>';
                }
            }
        }

        startGameButton.addEventListener('click', async () => {
            if (!currentRoomId || !currentUser) return;
            const roomRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}`);
            const gameId = `game_${Date.now()}`;
            const gameRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}/games/${gameId}`);

            try {
                const roomDoc = await getDoc(roomRef);
                if (!roomDoc.exists()) throw new Error("Room data not found.");
                const roomData = roomDoc.data();
                const playerIds = roomData.playerOrder || Object.keys(roomData.players);
                if (playerIds.length < 2) {
                    showMessage("Need one more player to start the adventure!", null);
                    return;
                }

                let gamePlayers = {};
                playerIds.forEach(pid => {
                    gamePlayers[pid] = {
                        username: roomData.players[pid].username,
                        score: 0,
                        lastAnswerTime: null
                    };
                });

                await setDoc(gameRef, {
                    gameId: gameId,
                    roomId: currentRoomId,
                    status: 'starting_round', 
                    currentRound: 1,
                    maxRounds: 3,
                    difficulty: roomData.difficulty || 'medium',
                    players: gamePlayers,
                    playerOrder: playerIds, 
                    roundData: {
                        1: { status: 'pending' },
                        2: { status: 'pending' },
                        3: { status: 'pending' }
                    }
                });
                await updateDoc(roomRef, {
                    status: 'playing',
                    currentGameId: gameId
                });
                console.log("Game started:", gameId);
            } catch (error) {
                console.error("Error starting game:", error);
                showMessage("Couldn't start the game. " + error.message, null);
            }
        });

        function initializeGameUI(roomData) {
            const players = roomData.players;
            const playerIds = roomData.playerOrder || Object.keys(players);

            if (playerIds.length > 0 && players[playerIds[0]]) {
                player1NameGame.textContent = players[playerIds[0]].username + (playerIds[0] === currentUser.uid ? " (You)" : "");
                player1ScoreGame.textContent = "0";
                player1AnswerStatus.textContent = "";
            }
            if (playerIds.length > 1 && players[playerIds[1]]) {
                player2NameGame.textContent = players[playerIds[1]].username + (playerIds[1] === currentUser.uid ? " (You)" : "");
                player2ScoreGame.textContent = "0";
                player2AnswerStatus.textContent = "";
            } else if (playerIds.length === 1) { 
                 player2NameGame.textContent = "Waiting for Player 2...";
                 player2ScoreGame.textContent = "0";
                 player2AnswerStatus.textContent = "";
            }
            answerInput.value = '';
            answerInput.disabled = true;
            submitAnswerButton.disabled = true;
            updateAnswerCount();
        }
        
        function subscribeToGameUpdates(roomId, gameId, isFinalRead = false) {
            if (gameUnsubscribe) gameUnsubscribe();
            const gameRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${roomId}/games/${gameId}`);

            gameUnsubscribe = onSnapshot(gameRef, async (docSnap) => {
                if (!docSnap.exists()) {
                    console.warn("Game document does not exist:", gameId);
                    if (!isFinalRead && !screens.game.classList.contains('hidden')) { 
                         showMessage("Game data seems to have floated away. Returning to lobby.", null);
                         setTimeout(() => leaveRoom(), 3000); 
                    }
                    return;
                }
                const gameData = docSnap.data();
                console.log("Game update:", gameData.status, "Round:", gameData.currentRound);
                updateGameUI(gameData); 

                if (gameData.status === 'game_over') {
                    displayGameOver(gameData);
                    if(!isFinalRead && gameUnsubscribe) gameUnsubscribe(); 
                    return;
                }
                if (isFinalRead && gameData.status === 'game_over'){ 
                    displayGameOver(gameData);
                    return;
                }

                const currentRoundNum = gameData.currentRound;
                const roundKey = `roundData.${currentRoundNum}`;
                const currentRoundData = gameData.roundData?.[currentRoundNum] || { status: 'pending' };

                if (gameData.status === 'starting_round') {
                    const roomDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/quizRooms/${roomId}`));
                    if (!roomDoc.exists()) return;
                    const roomCreatorUid = roomDoc.data().creatorUid;

                    if (currentUser.uid === roomCreatorUid) {
                        const questionText = await generateQuestionWithGemini(gameData.difficulty);
                        if (questionText) {
                            await updateDoc(gameRef, {
                                [`${roundKey}.questionText`]: questionText,
                                [`${roundKey}.status`]: 'question_ready',
                                [`${roundKey}.startTime`]: serverTimestamp(),
                                [`${roundKey}.answers`]: {},
                                [`${roundKey}.winner`]: null,
                                status: 'question_pending' 
                            });
                        } else {
                            showMessage("Host couldn't generate a question. The round can't start yet.", null);
                        }
                    }
                } else if (gameData.status === 'question_pending' && currentRoundData.status === 'question_ready') {
                    await updateDoc(gameRef, { status: 'active_round', [`${roundKey}.status`]: 'active' });
                } else if (gameData.status === 'active_round' && currentRoundData.status === 'active') {
                    questionDisplay.textContent = currentRoundData.questionText || "Loading question...";
                    answerInput.disabled = false;
                    submitAnswerButton.disabled = countAnswers(answerInput.value) < 8; // Re-evaluate based on current input
                    waitingForQuestionSpinner.classList.add('hidden');
                    startRoundTimer(currentRoundData.startTime, gameRef, currentRoundNum, roundKey);
                    
                    if (currentRoundData.answers && currentRoundData.answers[currentUser.uid]) {
                        answerInput.disabled = true;
                        submitAnswerButton.disabled = true;
                        answerInput.value = currentRoundData.answers[currentUser.uid].text;
                        showMessage("You've already shared your wisdom this round!", 2000);
                    } else {
                        answerInput.disabled = false;
                        // submitAnswerButton is handled by updateAnswerCount
                        if (answerInput.value === '') updateAnswerCount(); // Ensure button state is correct if input is empty
                    }
                } else if (gameData.status === 'round_over') {
                    if (roundTimerInterval) clearInterval(roundTimerInterval);
                    timerDisplay.textContent = "Round Over!";
                    answerInput.disabled = true;
                    submitAnswerButton.disabled = true;

                    const roundWinnerId = currentRoundData.winner;
                    if (roundWinnerId) {
                        const winnerUsername = gameData.players[roundWinnerId]?.username || "A clever player";
                        showMessage(`${winnerUsername} won Round ${currentRoundNum}! ✨`, 3000);
                    } else {
                        showMessage(`Round ${currentRoundNum} is complete. No points this time.`, 3000);
                    }
                    
                    const roomD = await getDoc(doc(db, `artifacts/${appId}/public/data/quizRooms/${roomId}`));
                     if (!roomD.exists()) return;
                    const roomCreatorUid = roomD.data().creatorUid;
                    if (currentUser.uid === roomCreatorUid) {
                        setTimeout(async () => { 
                            if (gameData.currentRound < gameData.maxRounds) {
                                await updateDoc(gameRef, {
                                    currentRound: gameData.currentRound + 1,
                                    status: 'starting_round'
                                });
                            } else {
                                await updateDoc(gameRef, { status: 'game_over' });
                            }
                        }, 3500);
                    }
                }
            }, (error) => {
                console.error("Error listening to game updates:", error);
                if (!isFinalRead) {
                    showMessage("Lost connection to the game. Trying to stay in the loop...", null);
                }
            });
        }

        function updateGameUI(gameData) {
            const playerIds = gameData.playerOrder || Object.keys(gameData.players);
            const players = gameData.players;

            if (playerIds.length > 0 && players[playerIds[0]]) {
                player1NameGame.textContent = players[playerIds[0]].username + (playerIds[0] === currentUser.uid ? " (You)" : "");
                player1ScoreGame.textContent = players[playerIds[0]].score || 0;
            } else { // Default if player 1 data is missing
                player1NameGame.textContent = "Player 1";
                player1ScoreGame.textContent = "0";
            }

            if (playerIds.length > 1 && players[playerIds[1]]) {
                player2NameGame.textContent = players[playerIds[1]].username + (playerIds[1] === currentUser.uid ? " (You)" : "");
                player2ScoreGame.textContent = players[playerIds[1]].score || 0;
            } else { // Default if player 2 data is missing or only one player
                player2NameGame.textContent = (playerIds.length > 1) ? "Player 2" : "Waiting...";
                player2ScoreGame.textContent = "0";
            }
            
            roundInfoDisplay.textContent = `Round ${gameData.currentRound} of ${gameData.maxRounds}`;

            const currentRoundNum = gameData.currentRound;
            const currentRoundData = gameData.roundData?.[currentRoundNum];
            if (currentRoundData && currentRoundData.answers) {
                player1AnswerStatus.textContent = (playerIds[0] && currentRoundData.answers[playerIds[0]]) ? "Answered!" : "Thinking...";
                if (playerIds.length > 1 && playerIds[1]) {
                     player2AnswerStatus.textContent = (currentRoundData.answers[playerIds[1]]) ? "Answered!" : "Thinking...";
                } else {
                     player2AnswerStatus.textContent = "";
                }
            } else {
                player1AnswerStatus.textContent = "Thinking...";
                player2AnswerStatus.textContent = (playerIds.length > 1) ? "Thinking..." : "";
            }

            if (gameData.status === 'active_round' || gameData.status === 'question_pending') {
                if (currentRoundData?.questionText) {
                    questionDisplay.textContent = currentRoundData.questionText;
                    waitingForQuestionSpinner.classList.add('hidden');
                } else {
                    questionDisplay.textContent = "Waiting for the next question...";
                    if (gameData.status === 'question_pending' || gameData.status === 'starting_round') waitingForQuestionSpinner.classList.remove('hidden');
                }
            }
        }
        
        function countAnswers(text) {
            if (!text.trim()) return 0;
            return text.split(/[\n,]+/).map(s => s.trim()).filter(s => s).length;
        }

        answerInput.addEventListener('input', updateAnswerCount);
        function updateAnswerCount() {
            const count = countAnswers(answerInput.value);
            answerCountDisplay.textContent = `${count} / 8 answers`;
            if (count >= 8) {
                answerCountDisplay.classList.remove('text-red-500');
                answerCountDisplay.classList.add('text-green-500');
                submitAnswerButton.disabled = answerInput.disabled; 
            } else {
                answerCountDisplay.classList.add('text-red-500');
                answerCountDisplay.classList.remove('text-green-500');
                submitAnswerButton.disabled = true;
            }
        }


        submitAnswerButton.addEventListener('click', async () => {
            if (!currentRoomId || !currentUser) return;
            const answerText = answerInput.value.trim();
            const numAnswers = countAnswers(answerText);

            if (numAnswers < 8) {
                showMessage("Almost there! You need at least 8 items.");
                return;
            }

            answerInput.disabled = true;
            submitAnswerButton.disabled = true;

            const roomDocForGameId = await getDoc(doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}`));
            if (!roomDocForGameId.exists() || !roomDocForGameId.data().currentGameId) {
                showMessage("Error: Hmm, the current game ID is missing.", null);
                answerInput.disabled = false; 
                updateAnswerCount(); 
                return;
            }
            const currentGameId = roomDocForGameId.data().currentGameId;
            const gameRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}/games/${currentGameId}`);
            
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw new Error("Game not found. It might have poofed!");
                    
                    const gameData = gameDoc.data();
                    const currentRoundNum = gameData.currentRound;
                    const roundKey = `roundData.${currentRoundNum}`;
                    const currentRoundData = gameData.roundData?.[currentRoundNum];

                    if (!currentRoundData || currentRoundData.status !== 'active') {
                        throw new Error("The round isn't active or its data is missing.");
                    }
                    if (currentRoundData.winner) {
                        throw new Error("Someone was quicker! This round is already won."); 
                    }
                    if (currentRoundData.answers && currentRoundData.answers[currentUser.uid]) {
                         throw new Error("You've already submitted your brilliant answers for this round.");
                    }

                    transaction.update(gameRef, {
                        [`${roundKey}.answers.${currentUser.uid}`]: {
                            text: answerText,
                            timestamp: serverTimestamp()
                        }
                    });
                    
                    if (!currentRoundData.winner) { 
                         transaction.update(gameRef, {
                            [`${roundKey}.winner`]: currentUser.uid,
                            [`${roundKey}.status`]: 'finished', 
                            [`players.${currentUser.uid}.score`]: (gameData.players[currentUser.uid].score || 0) + 1,
                            status: 'round_over' 
                        });
                    }
                });
                showMessage("Answers submitted! Well done! 🌟", 1500);

            } catch (error) {
                console.error("Error submitting answer:", error);
                showMessage(error.message || "Couldn't submit your answer. Please try again.", null);
                const gameDoc = await getDoc(gameRef); 
                if (gameDoc.exists()) {
                    const gameData = gameDoc.data();
                    const currentRoundNum = gameData.currentRound;
                    const currentRoundData = gameData.roundData?.[currentRoundNum];
                    if (currentRoundData && currentRoundData.status === 'active' && (!currentRoundData.answers || !currentRoundData.answers[currentUser.uid])) {
                        answerInput.disabled = false;
                        updateAnswerCount(); 
                    }
                }
            }
        });

        function startRoundTimer(startTimeObj, gameRef, roundNum, roundKey) {
            if (roundTimerInterval) clearInterval(roundTimerInterval);
            if (!startTimeObj || !startTimeObj.seconds) {
                timerDisplay.textContent = `Time: ${ROUND_DURATION}s`; 
                console.warn("startTimeObj is missing or invalid for round timer start.");
                return;
            }

            const serverStartTimeMs = startTimeObj.seconds * 1000 + (startTimeObj.nanoseconds / 1000000);
            
            roundTimerInterval = setInterval(async () => {
                const elapsedSeconds = Math.floor((Date.now() - serverStartTimeMs) / 1000);
                let timeLeft = ROUND_DURATION - elapsedSeconds;

                if (timeLeft <= 0) {
                    timeLeft = 0;
                    clearInterval(roundTimerInterval);
                    timerDisplay.textContent = "Time's up! ⌛";
                    answerInput.disabled = true;
                    submitAnswerButton.disabled = true;

                    const gameDoc = await getDoc(gameRef);
                    if (gameDoc.exists()) {
                        const gameData = gameDoc.data();
                        const currentRoundData = gameData.roundData?.[roundNum];
                        if (currentRoundData && currentRoundData.status === 'active' && !currentRoundData.winner) {
                            const roomD = await getDoc(doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}`));
                            if (roomD.exists() && roomD.data().creatorUid === currentUser.uid) {
                                console.log(`Host ${currentUser.uid} marking round ${roundNum} over due to time.`);
                                await updateDoc(gameRef, {
                                    [`${roundKey}.status`]: 'finished', 
                                    status: 'round_over'
                                });
                            }
                        }
                    }
                } else {
                    timerDisplay.textContent = `Time: ${timeLeft}s`;
                }
            }, 1000);
        }

        function displayGameOver(gameData) {
            if (roundTimerInterval) clearInterval(roundTimerInterval);
            showScreen('gameOver');
            
            const players = gameData.players;
            const playerIds = gameData.playerOrder || Object.keys(players);
            let winnerId = null;
            let maxScore = -1;
            let tie = false;

            finalScoresList.innerHTML = '';
            playerIds.forEach(pid => {
                const player = players[pid];
                if (player) {
                    const li = document.createElement('li');
                    li.className = 'text-lg text-gray-700';
                    li.textContent = `${player.username}: ${player.score || 0} points`; 
                    finalScoresList.appendChild(li);

                    if ((player.score || 0) > maxScore) {
                        maxScore = (player.score || 0);
                        winnerId = pid;
                        tie = false;
                    } else if ((player.score || 0) === maxScore && maxScore > -1) { // Ensure tie is only for actual scores
                        tie = true;
                    }
                }
            });

            if (tie) {
                winnerInfo.textContent = "It's a tie! Well played by all! 🎉";
            } else if (winnerId && players[winnerId]) {
                winnerInfo.textContent = `🏆 ${players[winnerId].username} is the Quiz Champion! 🏆`;
            } else {
                winnerInfo.textContent = "Game Over! Hope you had fun!"; 
            }
        }

        playAgainButton.addEventListener('click', async () => {
            if (!currentRoomId || !currentUser) return;
            
            const roomRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}`);
            const roomDoc = await getDoc(roomRef);
            if (roomDoc.exists() && roomDoc.data().creatorUid === currentUser.uid) {
                try {
                    const oldGameId = roomDoc.data().currentGameId;
                    if (oldGameId) {
                        console.log("Old game ID:", oldGameId, "- not deleting for potential review.");
                    }
                    await updateDoc(roomRef, {
                        status: 'waiting',
                        currentGameId: null 
                    });
                    showScreen('lobby'); 
                } catch (error) {
                    console.error("Error resetting room for play again:", error);
                    showMessage("Could not start a new game. Please go home and try again.", null);
                }
            } else if (roomDoc.exists()) { 
                showMessage("Waiting for the host to start a new game.", 3000);
                showScreen('lobby'); 
            } else {
                showMessage("This room has disappeared. Returning home.", null);
                leaveRoom(true);
            }
        });
        
        backToHomeButton.addEventListener('click', () => {
            leaveRoom(true); 
        });

        async function leaveRoom(isFullExit = false) {
            console.log(`leaveRoom called. isFullExit: ${isFullExit}, currentRoomId: ${currentRoomId}, currentUser: ${currentUser ? currentUser.uid : 'null'}`);
            if (roundTimerInterval) clearInterval(roundTimerInterval);
            if (roomUnsubscribe) {
                console.log("Unsubscribing from room updates.");
                roomUnsubscribe();
                roomUnsubscribe = null;
            }
            if (gameUnsubscribe) {
                console.log("Unsubscribing from game updates.");
                gameUnsubscribe();
                gameUnsubscribe = null;
            }

            if (currentRoomId && currentUser && !isFullExit) {
                const roomRef = doc(db, `artifacts/${appId}/public/data/quizRooms/${currentRoomId}`);
                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists()) {
                            console.log("Room doc does not exist in leaveRoom transaction.");
                            return; 
                        }
                        const roomData = roomDoc.data();
                        let players = {...roomData.players}; 
                        let playerOrder = [...(roomData.playerOrder || [])];
                        let creatorUid = roomData.creatorUid;

                        if (players[currentUser.uid]) {
                            delete players[currentUser.uid]; 
                            playerOrder = playerOrder.filter(uid => uid !== currentUser.uid);
                            console.log(`Player ${currentUser.uid} removed from room ${currentRoomId}. New player count: ${Object.keys(players).length}`);
                        }

                        if (Object.keys(players).length === 0) {
                            console.log(`Room ${currentRoomId} is empty. Deleting room.`);
                            transaction.delete(roomRef);
                        } else {
                            const updates = {
                                players: players,
                                playerOrder: playerOrder
                            };
                            if (currentUser.uid === creatorUid && playerOrder.length > 0) {
                                updates.creatorUid = playerOrder[0]; 
                                if(players[playerOrder[0]]) { 
                                    players[playerOrder[0]].isHost = true;
                                }
                                console.log(`Host ${currentUser.uid} left. New host: ${playerOrder[0]}`);
                            }
                            transaction.update(roomRef, updates);
                        }
                    });
                } catch (error) {
                    console.error("Error during player removal/room cleanup on leave:", error);
                }
            }
            
            currentRoomId = null;
            roomIdInput.value = '';
            showScreen('home');
        }

        // --- Initial Load & Event Listener Setup ---
        window.addEventListener('load', async () => {
            showScreen('home');
            await initializeAuth();

            if (leaveLobbyButton) {
                leaveLobbyButton.addEventListener('click', () => leaveRoom(false));
            }
            if (leaveGameButton) {
                leaveGameButton.addEventListener('click', () => leaveRoom(false));
            }

            window.addEventListener('beforeunload', (event) => {
                if (currentRoomId && currentUser) {
                    console.log("Attempting cleanup via beforeunload for room:", currentRoomId);
                }
            });
        });

    </script>
    <style>
        body { 
            font-family: 'Poppins', sans-serif; 
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 50%, #bae6fd 100%); /* Light blue gradient */
            color: #0f172a; /* Dark slate for primary text */
            transition: background-color 0.5s ease;
        }
        .btn { 
            @apply px-6 py-3 rounded-xl font-semibold shadow-lg transition-all duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 transform hover:scale-105;
        }
        .btn-primary { @apply bg-sky-500 hover:bg-sky-600 text-white focus:ring-sky-400; }
        .btn-secondary { @apply bg-teal-500 hover:bg-teal-600 text-white focus:ring-teal-400; }
        .btn-danger { @apply bg-rose-500 hover:bg-rose-600 text-white focus:ring-rose-400; }
        
        .input-field { 
            @apply bg-white/80 border border-sky-300 text-slate-700 placeholder-slate-400 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-3 shadow-sm backdrop-blur-sm;
        }
        .card { 
            @apply bg-white/70 backdrop-blur-md p-6 md:p-8 rounded-2xl shadow-xl border border-white/30; 
        }
        .screen { @apply min-h-screen flex flex-col items-center justify-center p-4; }
        
        /* Custom spinner with softer colors */
        .loader {
            border: 4px solid #cffafe; /* Light cyan */
            border-top: 4px solid #06b6d4; /* Cyan */
            border-radius: 50%;
            width: 28px;
            height: 28px;
            animation: spin 1.2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Title styling */
        .game-title {
            @apply text-5xl font-bold mb-10 bg-clip-text text-transparent bg-gradient-to-r from-sky-400 to-emerald-500;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        .screen-title {
            @apply text-4xl font-bold mb-8 bg-clip-text text-transparent bg-gradient-to-r from-sky-500 to-teal-500;
        }
        .lobby-room-id {
            @apply text-slate-500 mb-6 text-2xl font-mono bg-sky-100/70 px-3 py-1 rounded-md inline-block shadow-sm;
        }
        .question-box {
            @apply mb-6 p-5 bg-sky-50 rounded-xl min-h-[100px] flex items-center justify-center text-center shadow-inner border border-sky-200;
        }
        .question-text {
            @apply text-xl text-sky-800 font-medium;
        }
        .scoreboard-card {
            @apply bg-white/50 p-4 rounded-lg shadow-md border border-white/20;
        }
        .player-name {
            @apply font-semibold text-sky-700 text-lg;
        }
        .player-score {
            @apply text-slate-600;
        }
        .player-status {
             @apply text-sm text-teal-600 italic;
        }
         .timer-display {
            @apply text-2xl font-semibold text-amber-600 bg-amber-100/70 px-3 py-1 rounded-md shadow-sm;
        }
        .answer-count {
            @apply text-sm mt-1; /* Base style, color set in JS */
        }
        .modal-card {
             @apply bg-gradient-to-br from-white via-sky-50 to-teal-50 p-6 rounded-xl shadow-2xl text-center max-w-sm w-full border border-sky-200;
        }
        .modal-text {
            @apply text-slate-700 mb-6 text-lg;
        }

    </style>
</head>
<body class="antialiased">

    <div id="messageOverlay" class="hidden fixed inset-0 bg-slate-900/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div class="modal-card">
            <p id="messageText" class="modal-text"></p>
            <button id="closeMessageButton" class="btn btn-primary">Got it!</button>
        </div>
    </div>

    <div id="homeScreen" class="screen">
        <div class="card w-full max-w-lg text-center">
            <h1 class="game-title">Daily Bloom Quiz</h1>
            <div class="space-y-6">
                <div>
                    <label for="usernameInput" class="block mb-2 text-sm font-medium text-slate-600">Your Name:</label>
                    <input type="text" id="usernameInput" class="input-field" placeholder="Quiz Explorer" required>
                </div>
                <div>
                    <label for="difficultySelect" class="block mb-2 text-sm font-medium text-slate-600">Choose Challenge Level:</label>
                    <select id="difficultySelect" class="input-field">
                        <option value="easy">Gentle Breeze (Easy)</option>
                        <option value="medium" selected>Steady Path (Medium)</option>
                        <option value="hard">Mountain Peak (Hard)</option>
                    </select>
                </div>
                <button id="createRoomButton" class="btn btn-primary w-full">Create a New Quiz Room</button>
                <hr class="border-sky-200 my-6">
                <div>
                    <label for="roomIdInput" class="block mb-2 text-sm font-medium text-slate-600">Room ID to Join:</label>
                    <input type="text" id="roomIdInput" class="input-field mb-4" placeholder="ABCDE">
                    <button id="joinRoomButton" class="btn btn-secondary w-full">Join an Existing Room</button>
                </div>
            </div>
        </div>
    </div>

    <div id="lobbyScreen" class="screen hidden">
        <div class="card w-full max-w-xl text-center">
            <h2 class="screen-title">Quiz Lobby</h2>
            <p id="currentRoomIdDisplay" class="lobby-room-id"></p>
            <h3 class="text-2xl font-semibold mb-4 text-slate-700">Players Ready:</h3>
            <ul id="playerListLobby" class="space-y-3 mb-8">
                </ul>
            <button id="startGameButton" class="btn btn-primary w-full hidden text-lg">Let the Quiz Begin!</button>
            <button id="leaveLobbyButton" class="btn btn-danger w-full mt-4">Leave Lobby</button> 
        </div>
    </div>

    <div id="gameScreen" class="screen hidden">
        <div class="card w-full max-w-3xl">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
                <h2 id="roundInfoDisplay" class="text-3xl font-bold text-sky-600">Round 1 of 3</h2>
                <div id="timerDisplay" class="timer-display">Time: 60s</div>
            </div>

            <div class="question-box">
                 <div id="waitingForQuestionSpinner" class="loader hidden mr-3"></div>
                <p id="questionDisplay" class="question-text">Waiting for question...</p>
            </div>

            <div class="mb-6">
                <label for="answerInput" class="block mb-2 text-sm font-medium text-slate-600">Your 8 Answers (one per line, or comma-separated):</label>
                <textarea id="answerInput" rows="6" class="input-field text-base" placeholder="e.g., Morning coffee, Checking emails, Planning the day..."></textarea>
                <p id="answerCountDisplay" class="answer-count text-slate-500">0 / 8 answers</p>
            </div>
            <button id="submitAnswerButton" class="btn btn-primary w-full mb-8 text-lg" disabled>Submit My Answers!</button>

            <h3 class="text-xl font-semibold mb-4 text-slate-700">Scoreboard:</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="scoreboard-card">
                    <p id="player1NameGame" class="player-name">Player 1</p>
                    <p class="player-score">Score: <span id="player1ScoreGame">0</span></p>
                    <p id="player1AnswerStatus" class="player-status">Thinking...</p>
                </div>
                <div class="scoreboard-card">
                    <p id="player2NameGame" class="player-name">Player 2</p>
                    <p class="player-score">Score: <span id="player2ScoreGame">0</span></p>
                    <p id="player2AnswerStatus" class="player-status">Thinking...</p>
                </div>
            </div>
             <button id="leaveGameButton" class="btn btn-danger w-full mt-8">Leave Game (Forfeit)</button> 
        </div>
    </div>

    <div id="gameOverScreen" class="screen hidden">
        <div class="card w-full max-w-lg text-center">
            <h2 class="text-5xl font-bold text-rose-500 mb-6">Game Over!</h2>
            <p id="winnerInfo" class="text-3xl text-teal-600 mb-8 font-semibold">Winner is...</p>
            <h3 class="text-xl font-semibold mb-3 text-slate-700">Final Scores:</h3>
            <ul id="finalScoresList" class="space-y-2 mb-10">
                </ul>
            <div class="space-y-4">
                <button id="playAgainButton" class="btn btn-primary w-full text-lg">Play Again in this Room?</button>
                <button id="backToHomeButton" class="btn btn-secondary w-full">Back to Home Screen</button>
            </div>
        </div>
    </div>

</body>
</html>
